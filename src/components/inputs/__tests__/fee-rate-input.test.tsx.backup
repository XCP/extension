/**
 * @vitest-environment happy-dom
 */
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { render, screen, fireEvent, waitFor, within, act } from '@testing-library/react';
import '@testing-library/jest-dom/vitest';
import { FeeRateInput } from '../fee-rate-input';

// Setup portal root for Headless UI
beforeEach(() => {
  const portalRoot = document.createElement('div');
  portalRoot.setAttribute('id', 'headlessui-portal-root');
  document.body.appendChild(portalRoot);
});

afterEach(() => {
  const portalRoot = document.getElementById('headlessui-portal-root');
  if (portalRoot) {
    document.body.removeChild(portalRoot);
  }
});

// Mock the useFeeRates hook
vi.mock('@/hooks/useFeeRates', () => ({
  useFeeRates: vi.fn()
}));

import { useFeeRates } from '@/hooks/useFeeRates';

describe('FeeRateInput', () => {
  const mockUseFeeRates = useFeeRates as any;

  beforeEach(() => {
    vi.clearAllMocks();
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  describe('Loading state', () => {
    it('should show loading message when fee rates are loading', () => {
      mockUseFeeRates.mockReturnValue({
        feeRates: null,
        loading: true,
        error: null,
        uniquePresetOptions: []
      });

      render(<FeeRateInput />);
      expect(screen.getByText('Loading fee ratesâ€¦')).toBeInTheDocument();
    });

    it('should include hidden input with default value when loading', () => {
      mockUseFeeRates.mockReturnValue({
        feeRates: null,
        loading: true,
        error: null,
        uniquePresetOptions: []
      });

      const { container } = render(<FeeRateInput />);
      const hiddenInput = container.querySelector('input[type="hidden"][name="sat_per_vbyte"]') as HTMLInputElement;
      expect(hiddenInput).toBeInTheDocument();
      expect(hiddenInput.value).toBe('0.1');
    });
  });

  describe('Error state', () => {
    it('should show custom input when fee rates fail to load', () => {
      mockUseFeeRates.mockReturnValue({
        feeRates: null,
        loading: false,
        error: 'Failed to fetch',
        uniquePresetOptions: []
      });

      render(<FeeRateInput />);
      
      expect(screen.getByLabelText('Custom Fee Rate')).toBeInTheDocument();
      expect(screen.getByText('Fee Rate (Custom)')).toBeInTheDocument();
    });

    it('should show help text when error occurs and showHelpText is true', () => {
      mockUseFeeRates.mockReturnValue({
        feeRates: null,
        loading: false,
        error: 'Failed to fetch',
        uniquePresetOptions: []
      });

      render(<FeeRateInput showHelpText />);
      
      expect(screen.getByText('Unable to fetch fee rates. Please enter a custom fee rate (minimum 0.1 sat/vB).')).toBeInTheDocument();
    });
  });

  describe('Preset options', () => {
    const mockFeeRates = {
      fastestFee: 10,
      halfHourFee: 8,
      hourFee: 5,
      economyFee: 2,
      minimumFee: 1
    };

    const mockPresetOptions = [
      { id: 'fast', name: 'Fast', value: 10 },
      { id: 'medium', name: 'Medium', value: 5 },
      { id: 'slow', name: 'Slow', value: 2 }
    ];

    beforeEach(() => {
      mockUseFeeRates.mockReturnValue({
        feeRates: mockFeeRates,
        loading: false,
        error: null,
        uniquePresetOptions: mockPresetOptions
      });
    });

    it('should display dropdown with preset options', () => {
      render(<FeeRateInput />);
      
      const button = screen.getByRole('button');
      expect(button).toHaveTextContent('Fast');
      expect(button).toHaveTextContent('10 sat/vB');
    });

    it.skip('should show all preset options when dropdown is opened', async () => {
      render(<FeeRateInput />);
      
      const button = screen.getByRole('button');
      
      await act(async () => {
        fireEvent.click(button);
      });
      
      // Options should be visible after clicking
      await waitFor(() => {
        expect(screen.getByText('Medium')).toBeInTheDocument();
      });
      
      expect(screen.getByText('Slow')).toBeInTheDocument();
      expect(screen.getByText('Custom')).toBeInTheDocument();
    });

    it.skip('should update selection when preset is clicked', async () => {
      render(<FeeRateInput />);
      
      const button = screen.getByRole('button');
      
      await act(async () => {
        fireEvent.click(button);
      });
      
      await waitFor(() => {
        expect(screen.getByText('Medium')).toBeInTheDocument();
      });
      
      await act(async () => {
        fireEvent.click(screen.getByText('Medium'));
      });
      
      expect(button).toHaveTextContent('Medium');
      expect(button).toHaveTextContent('5 sat/vB');
    });

    it('should include hidden input with current value', () => {
      const { container } = render(<FeeRateInput />);
      
      const hiddenInput = container.querySelector('input[type="hidden"][name="sat_per_vbyte"]') as HTMLInputElement;
      expect(hiddenInput).toBeInTheDocument();
      expect(hiddenInput.value).toBe('10'); // Fast preset value
    });

    it.skip('should call onFeeRateChange when preset is selected', async () => {
      const onFeeRateChange = vi.fn();
      render(<FeeRateInput onFeeRateChange={onFeeRateChange} />);
      
      const button = screen.getByRole('button');
      
      await act(async () => {
        fireEvent.click(button);
      });
      
      await waitFor(() => {
        expect(screen.getByText('Medium')).toBeInTheDocument();
      });
      
      await act(async () => {
        fireEvent.click(screen.getByText('Medium'));
      });
      
      expect(onFeeRateChange).toHaveBeenCalledWith(5);
    });
  });

  describe('Custom input mode', () => {
    const mockFeeRates = {
      fastestFee: 10,
      halfHourFee: 8,
      hourFee: 5,
      economyFee: 2,
      minimumFee: 1
    };

    const mockPresetOptions = [
      { id: 'fast', name: 'Fast', value: 10 },
      { id: 'medium', name: 'Medium', value: 5 },
      { id: 'slow', name: 'Slow', value: 2 }
    ];

    beforeEach(() => {
      mockUseFeeRates.mockReturnValue({
        feeRates: mockFeeRates,
        loading: false,
        error: null,
        uniquePresetOptions: mockPresetOptions
      });
    });

    it.skip('should switch to custom input when Custom is selected', async () => {
      render(<FeeRateInput />);
      
      const button = screen.getByRole('button');
      
      await act(async () => {
        fireEvent.click(button);
      });
      
      await waitFor(() => {
        expect(screen.getByText('Custom')).toBeInTheDocument();
      });
      
      await act(async () => {
        fireEvent.click(screen.getByText('Custom'));
      });
      
      const input = screen.getByLabelText('Custom Fee Rate') as HTMLInputElement;
      expect(input).toBeInTheDocument();
      expect(input.type).toBe('number');
    });

    it.skip('should show Esc button in custom mode', async () => {
      render(<FeeRateInput />);
      
      const button = screen.getByRole('button');
      
      await act(async () => {
        fireEvent.click(button);
      });
      
      await waitFor(() => {
        expect(screen.getByText('Custom')).toBeInTheDocument();
      });
      
      await act(async () => {
        fireEvent.click(screen.getByText('Custom'));
      });
      
      expect(screen.getByLabelText('Reset to first preset')).toBeInTheDocument();
    });

    it.skip('should reset to first preset when Esc is clicked', async () => {
      render(<FeeRateInput />);
      
      // Switch to custom
      const button = screen.getByRole('button');
      
      await act(async () => {
        fireEvent.click(button);
      });
      
      await waitFor(() => {
        expect(screen.getByText('Custom')).toBeInTheDocument();
      });
      
      await act(async () => {
        fireEvent.click(screen.getByText('Custom'));
      });
      
      // Click Esc
      await act(async () => {
        fireEvent.click(screen.getByLabelText('Reset to first preset'));
      });
      
      // Should be back to Fast preset
      expect(screen.getByRole('button')).toHaveTextContent('Fast');
    });

    it.skip('should validate minimum fee rate of 0.1', async () => {
      render(<FeeRateInput />);
      
      // Switch to custom
      const button = screen.getByRole('button');
      
      await act(async () => {
        fireEvent.click(button);
      });
      
      await waitFor(() => {
        expect(screen.getByText('Custom')).toBeInTheDocument();
      });
      
      await act(async () => {
        fireEvent.click(screen.getByText('Custom'));
      });
      
      const input = screen.getByLabelText('Custom Fee Rate') as HTMLInputElement;
      fireEvent.change(input, { target: { value: '0.05' } });
      
      expect(screen.getByText('Fee rate must be at least 0.1 sat/vB.')).toBeInTheDocument();
      expect(input.value).toBe('0.1');
    });

    it.skip('should allow valid numeric input', async () => {
      render(<FeeRateInput />);
      
      // Switch to custom
      const button = screen.getByRole('button');
      
      await act(async () => {
        fireEvent.click(button);
      });
      
      await waitFor(() => {
        expect(screen.getByText('Custom')).toBeInTheDocument();
      });
      
      await act(async () => {
        fireEvent.click(screen.getByText('Custom'));
      });
      
      const input = screen.getByLabelText('Custom Fee Rate') as HTMLInputElement;
      fireEvent.change(input, { target: { value: '25.5' } });
      
      expect(input.value).toBe('25.5');
      expect(screen.queryByText('Fee rate must be at least 0.1 sat/vB.')).not.toBeInTheDocument();
    });

    it.skip('should ignore non-numeric input', async () => {
      render(<FeeRateInput />);
      
      // Switch to custom
      const button = screen.getByRole('button');
      
      await act(async () => {
        fireEvent.click(button);
      });
      
      await waitFor(() => {
        expect(screen.getByText('Custom')).toBeInTheDocument();
      });
      
      await act(async () => {
        fireEvent.click(screen.getByText('Custom'));
      });
      
      const input = screen.getByLabelText('Custom Fee Rate') as HTMLInputElement;
      const initialValue = input.value;
      
      fireEvent.change(input, { target: { value: 'abc' } });
      
      // Should maintain previous value
      expect(input.value).toBe(initialValue);
    });

    it.skip('should handle empty input temporarily', async () => {
      render(<FeeRateInput />);
      
      // Switch to custom
      const button = screen.getByRole('button');
      
      await act(async () => {
        fireEvent.click(button);
      });
      
      await waitFor(() => {
        expect(screen.getByText('Custom')).toBeInTheDocument();
      });
      
      await act(async () => {
        fireEvent.click(screen.getByText('Custom'));
      });
      
      const input = screen.getByLabelText('Custom Fee Rate') as HTMLInputElement;
      fireEvent.change(input, { target: { value: '' } });
      
      expect(input.value).toBe('');
    });

    it.skip('should limit to one decimal point', async () => {
      render(<FeeRateInput />);
      
      // Switch to custom
      const button = screen.getByRole('button');
      
      await act(async () => {
        fireEvent.click(button);
      });
      
      await waitFor(() => {
        expect(screen.getByText('Custom')).toBeInTheDocument();
      });
      
      await act(async () => {
        fireEvent.click(screen.getByText('Custom'));
      });
      
      const input = screen.getByLabelText('Custom Fee Rate') as HTMLInputElement;
      
      // Try to enter multiple decimal points
      fireEvent.change(input, { target: { value: '10.5.5' } });
      
      // Should maintain the original value since the input is invalid
      expect(input.value).not.toBe('10.5.5');
    });

    it.skip('should call onFeeRateChange when custom value changes', async () => {
      const onFeeRateChange = vi.fn();
      render(<FeeRateInput onFeeRateChange={onFeeRateChange} />);
      
      // Switch to custom
      const button = screen.getByRole('button');
      
      await act(async () => {
        fireEvent.click(button);
      });
      
      await waitFor(() => {
        expect(screen.getByText('Custom')).toBeInTheDocument();
      });
      
      await act(async () => {
        fireEvent.click(screen.getByText('Custom'));
      });
      
      const input = screen.getByLabelText('Custom Fee Rate') as HTMLInputElement;
      fireEvent.change(input, { target: { value: '15' } });
      
      expect(onFeeRateChange).toHaveBeenCalledWith(15);
    });
  });

  describe('Disabled state', () => {
    const mockFeeRates = {
      fastestFee: 10,
      halfHourFee: 8,
      hourFee: 5,
      economyFee: 2,
      minimumFee: 1
    };

    const mockPresetOptions = [
      { id: 'fast', name: 'Fast', value: 10 }
    ];

    beforeEach(() => {
      mockUseFeeRates.mockReturnValue({
        feeRates: mockFeeRates,
        loading: false,
        error: null,
        uniquePresetOptions: mockPresetOptions
      });
    });

    it('should disable dropdown when disabled prop is true', () => {
      render(<FeeRateInput disabled />);
      
      const button = screen.getByRole('button');
      expect(button).toBeDisabled();
    });

    it.skip('should disable custom input when disabled prop is true', () => {
      render(<FeeRateInput disabled />);
      
      // Switch to custom first (when not disabled)
      const { rerender } = render(<FeeRateInput />);
      const button = screen.getByRole('button');
      fireEvent.click(button);
      fireEvent.click(screen.getByText('Custom'));
      
      // Now disable it
      rerender(<FeeRateInput disabled />);
      
      const input = screen.getByLabelText('Custom Fee Rate') as HTMLInputElement;
      expect(input).toBeDisabled();
    });

    it.skip('should disable Esc button when disabled', async () => {
      mockUseFeeRates.mockReturnValue({
        feeRates: mockFeeRates,
        loading: false,
        error: null,
        uniquePresetOptions: mockPresetOptions
      });

      // First render without disabled to switch to custom
      const { rerender } = render(<FeeRateInput />);
      
      const button = screen.getByRole('button');
      
      await act(async () => {
        fireEvent.click(button);
      });
      
      await waitFor(() => {
        expect(screen.getByText('Custom')).toBeInTheDocument();
      });
      
      await act(async () => {
        fireEvent.click(screen.getByText('Custom'));
      });
      
      // Now render with disabled
      rerender(<FeeRateInput disabled />);
      
      const escButton = screen.getByLabelText('Reset to first preset');
      expect(escButton).toBeDisabled();
    });
  });

  describe('Help text', () => {
    const mockFeeRates = {
      fastestFee: 10,
      halfHourFee: 8,
      hourFee: 5,
      economyFee: 2,
      minimumFee: 1
    };

    beforeEach(() => {
      mockUseFeeRates.mockReturnValue({
        feeRates: mockFeeRates,
        loading: false,
        error: null,
        uniquePresetOptions: [{ id: 'fast', name: 'Fast', value: 10 }]
      });
    });

    it('should show help text when showHelpText is true', () => {
      render(<FeeRateInput showHelpText />);
      
      expect(screen.getByText('Pre-populated with current rates (min 0.1 sat/vB).')).toBeInTheDocument();
    });

    it('should not show help text when showHelpText is false', () => {
      render(<FeeRateInput showHelpText={false} />);
      
      expect(screen.queryByText('Pre-populated with current rates (min 0.1 sat/vB).')).not.toBeInTheDocument();
    });
  });

  describe('Accessibility', () => {
    const mockFeeRates = {
      fastestFee: 10,
      halfHourFee: 8,
      hourFee: 5,
      economyFee: 2,
      minimumFee: 1
    };

    beforeEach(() => {
      mockUseFeeRates.mockReturnValue({
        feeRates: mockFeeRates,
        loading: false,
        error: null,
        uniquePresetOptions: [{ id: 'fast', name: 'Fast', value: 10 }]
      });
    });

    it('should have required indicator', () => {
      render(<FeeRateInput />);
      
      expect(screen.getByText('*')).toBeInTheDocument();
      expect(screen.getByText('*')).toHaveClass('text-red-500');
    });

    it.skip('should have proper aria attributes on custom input', async () => {
      render(<FeeRateInput />);
      
      // Switch to custom
      const button = screen.getByRole('button');
      
      await act(async () => {
        fireEvent.click(button);
      });
      
      await waitFor(() => {
        expect(screen.getByText('Custom')).toBeInTheDocument();
      });
      
      await act(async () => {
        fireEvent.click(screen.getByText('Custom'));
      });
      
      const input = screen.getByLabelText('Custom Fee Rate');
      expect(input).toHaveAttribute('aria-label', 'Custom Fee Rate');
      expect(input).toHaveAttribute('required');
    });

    it.skip('should have aria-invalid when error occurs', async () => {
      render(<FeeRateInput />);
      
      // Switch to custom
      const button = screen.getByRole('button');
      
      await act(async () => {
        fireEvent.click(button);
      });
      
      await waitFor(() => {
        expect(screen.getByText('Custom')).toBeInTheDocument();
      });
      
      await act(async () => {
        fireEvent.click(screen.getByText('Custom'));
      });
      
      const input = screen.getByLabelText('Custom Fee Rate') as HTMLInputElement;
      fireEvent.change(input, { target: { value: '0.05' } });
      
      expect(input).toHaveAttribute('aria-invalid', 'true');
      expect(input).toHaveAttribute('aria-describedby', 'sat_per_vbyte-error');
    });
  });
});